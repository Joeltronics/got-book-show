#!/usr/bin/env python3

"""
Game of Thrones chapters vs episodes chart generator
Copyright (c) 2013-2018, Joel Geddert

This script generates an HTML file of the table.

Software License:
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.

A note from the author:
	The original chart generated by this code, as well as all remaining applicable
	source & asset files (except where noted), are licensed under a Creative Commons
	BY-SA 4.0 license <http://creativecommons.org/licenses/by-sa/4.0/>. If you are
	going to use any of this code to create a derivative work, please respect this
	CC license.
"""

import string
from typing import List, Callable


_debug = False


def set_debug(val=True):
	global _debug

	print('Setting debug: ' + str(val))

	_debug = val


def is_debug():
	return _debug


def debug_print(*args, **kwargs):
	if is_debug():
		print(*args, **kwargs)


def find_unique(list: List, matching_function: Callable):
	"""Find an item in a list, according to matching_function
	Assumes there is a single of the item in the list

	:param list: list to find in
	:param matching_function:
	:return: the item
	:raises: ValueError if item is not in list or if multiple matches
	"""
	vals = [item for item in list if matching_function(item)]
	if len(vals) == 0:
		raise ValueError('Failed to find item in list')
	elif len(vals) > 1:
		raise ValueError('Multiple matches in list')
	return vals[0]


# No point importing numpy for a single function
def cumsum(x):
	return [sum(x[:i + 1]) for i in range(len(x))]


# Not the best way of doing this, but it's only used for season numbers so it probably only ever needs to support 1-10
def toRomanNumeral(num):
	romnums = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X']
	if (num < 1) or (num > len(romnums)):
		# Fallback in case the show is more than 10 seasons and I forget to update the code yet
		print("WARNING: roman numeral out of bounds")
		return num
	else:
		return romnums[num - 1]


# Approximation for string length
# This isn't going to be perfect because that requires not only rendering the text, but doing it
# in exactly the font (and kerning) the browser will use
# These method should be close enough
def stringLen(s):
	n = 0
	# Iterate 1 character at a time
	for c in s:
		if c in '.\'':
			n += 0.33
		elif c in ' iIl':
			n += 0.5
		elif c in 'ACDGmw':
			n += 1.25
		elif c in 'MOQW':
			n += 1.5
		elif c in string.ascii_lowercase + string.ascii_uppercase + string.digits + '?':
			n += 1
		else:
			print('WARNING: unknown char ' + c + ' in string ' + s)
			n += 1

	return n


# Prefix is something we want to prepend to string, that will always be prepended in full
# and won't count toward checking if string is just 'the' or blank
# (i.e. prepending book abbreviation or number to chapter name)
def abbrevString(s, nChar, prefix=''):
	bAddPrefix = (prefix != '')

	if bAddPrefix:
		prefix = prefix + ' '
		# Make room in character limit for prefix
		nChar -= stringLen(prefix)

	# Check if we even need to abbreviate at all
	if stringLen(s) <= nChar:
		if bAddPrefix:
			return prefix + s
		else:
			return s

	# Once we reach this point, we know we need to abbreviate.
	# Make room in character limit for however many characters ellipsis will take
	nChar -= stringLen('...')

	# Try taking as many whole words as we can fit
	ss = s.split()
	nwords = len(ss)
	outstr = ''
	for n in range(nwords):
		if stringLen(' '.join(ss[0:n])) < nChar:
			outstr = ' '.join(ss[0:n])
		else:
			break

	# Now check if this ended up abbreviating to blank or just 'the'
	# If so, instead take as many characters as possible
	if (outstr == '') or (outstr.lower() == 'the'):
		outstr = ''
		for c in s:
			if stringLen(outstr + c) >= nChar:
				break
			outstr += c

	# If it ended on an apostrophe, remove it
	if outstr[-1:] == '\'':
		outstr = outstr[:-1]

	if bAddPrefix:
		outstr = prefix + outstr

	outstr += '...'

	debug_print("Abbreviating chapter '" + prefix + s + "' as '" + outstr + "'")

	return outstr
