#!/usr/bin/env python3

"""
Game of Thrones chapters vs episodes chart generator
Copyright (c) 2013-2018, Joel Geddert

This script generates an HTML file of the table.

Software License:
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.

A note from the author:
	The original chart generated by this code, as well as all remaining applicable
	source & asset files (except where noted), are licensed under a Creative Commons
	BY-SA 4.0 license <http://creativecommons.org/licenses/by-sa/4.0/>. If you are
	going to use any of this code to create a derivative work, please respect this
	CC license.
"""


from utils import *
from book_show_types import *
import os.path
import csv


_booksFilename = os.path.join('input', 'books.csv')
_chapterFilename = os.path.join('input', 'chapters.csv')
_combinedFilename = os.path.join('input', 'combined.txt')
_episodeFilename = os.path.join('input', 'episodes.csv')
_connectionsFilename = os.path.join('input', 'connections.csv')

_tab = "\t"


def parse_books():
	print("Processing %s" % _booksFilename)
	book_list = []

	with open(_booksFilename) as csv_file:
		reader = csv.reader(csv_file)
		headers = next(reader)

		n = 1
		for row in reader:

			# Skip blank rows
			if not any(row):
				continue

			book_dict = {header: value for header, value in zip(headers, row)}
			book_list.append(Book(number=n, **book_dict))
			n += 1

	return book_list


def parse_chapters(book_list):
	print("Processing", _chapterFilename)

	chapter_list = []
	total_chap_num = 0

	with open(_chapterFilename) as csvFile:
		reader = csv.reader(csvFile)
		next(reader)

		for row in reader:
			if not any(row):
				continue

			bookname = row[0]
			chapNum = int(row[1])
			chapName = row[2]
			povchar = row[3]
			if povchar == '':
				# if no POV char given in CSV file, use first word of chapter name
				povchar = row[2].split()[0]
				if povchar[0:3].lower() in ["pro", "epi"]:
					# If it's a prologue/epilogue then always make it "other"
					povchar = "Other"
				elif povchar[0:3].lower() == "the":
					# IF it's a "the" chapter, there should be a pov char set!
					print("WARNING: no POV char given for chapter " + chapName)
					povchar = "Other"
			location = row[4]
			storyline = [row[5].lower()]
			if (row[6] != ""):
				storyline.append(row[6].lower())
			occurred = row[7]

			matching_books = [book for book in book_list if book.name == bookname]

			if not matching_books:
				raise ValueError('Could not find book matching name "%s"' % bookname)
			elif len(matching_books) > 1:
				print('WARNING: found multiple books matching name "%s"' % bookname)

			book = matching_books[0]
			book.num_chapters += 1

			total_chap_num += 1

			chapter_list.append(Chapter(
				number=total_chap_num,
				book=book,
				number_in_book=chapNum,
				name=chapName,
				pov_char=povchar,
				storyline=storyline,
				location=location,
				occurred=occurred,
			))

	debug_print(repr(chapter_list[0:10]))

	book_num_chap = [book.num_chapters for book in book_list]

	book_chap_offset = [0] + cumsum(book_num_chap)

	for n, book in enumerate(book_list):
		book.first_chapter_offset = book_chap_offset[n]

	return chapter_list


def parse_combined_order(chapters, books):
	print("Processing", _combinedFilename)
	combined_chapter_list = []
	with open(_combinedFilename, 'rU') as txtFile:
		line = txtFile.readline()
		while line:

			words = line.split()
			words = [word.lower() for word in words]

			book_num = 0

			if 'affc' in words:
				book_num = 4
				n = words.index('affc')
			elif 'adwd' in words:
				book_num = 5
				n = words.index('adwd')
			else:
				print("ERROR: neither AFFC nor ADWD not found in line:")
				print(line)
				line = txtFile.readline()
				continue

			# combined.txt 1-indexes chapters
			chapNum = int(words[n + 1]) - 1

			chapter = chapters[chapNum + books[book_num - 1].first_chapter_offset]
			combined_chapter_list.append(chapter)

			debug_print(chapter)
			debug_print(line)

			line = txtFile.readline()
	return combined_chapter_list


def parse_episodes():
	print("Processing", _episodeFilename)
	episode_list = []
	with open(_episodeFilename) as csvFile:

		reader = csv.reader(csvFile)
		next(reader)
		number = 1

		for row in reader:
			if not any(row):
				continue

			season = int(row[0])
			name = row[3]
			name = name[1:-1]
			debug_print(name)
			episode_list.append(Episode(number=number, season=season, name=name))
			number += 1

	return episode_list


def parse_connections(db):
	print("Processing", _connectionsFilename)
	connList = []
	with open(_connectionsFilename) as csvFile:
		connectionfile = csv.reader(csvFile)
		for row in connectionfile:
			if row[0].isdigit():

				# FIXME: this assumes 10 episodes per season
				ep_num = int(row[1]) + 10 * (int(row[0]) - 1)
				book_num = int(row[2])
				chap_name = row[3]
				strength = row[4]
				major = row[5]
				notes = row[6]

				if (chap_name == '') or (chap_name == '?'):
					continue

				if strength not in ['0', '1']:
					print("WARNING: chapter strength not 0 or 1")
					print(_tab, "book ", book_num, " chap_name ", chap_name, sep="")
					print(_tab, "strength: ", strength, sep="")
					continue
				strength = int(strength)

				# Make sure chapter name is in the list of chapters!
				chapter = db.find_chapter(chap_name, book_num)

				if not chapter:
					print("WARNING: Chapter not found:")
					print(_tab, "book ", book_num, " chap_name ", chap_name, sep="")
					print(_tab, "notes: ", notes, sep="")

				episode = db.episodes[ep_num - 1]

				connList.append(Connection(
					episode=episode,
					chapter=chapter,
					strength=strength,
					major=major,
					notes=notes,
				))

	debug_print(repr(connList[0:10]))

	return connList


def do_parsing() -> DB:

	db = DB()

	db.books = parse_books()

	db.chapters = parse_chapters(db.books)

	print("")
	print("%i chapters in %i" % (len(db.chapters), len(db.books)))
	for n, book in enumerate(db.books):
		print("%i: %s" % (n+1, repr(book)))
	print("")

	combined_chapter_list = parse_combined_order(db.chapters, db.books)

	print(len(combined_chapter_list), "chapters in books 4+5")

	# Have to use list(), otherwise it just copies reference and that's bad
	db.chapters_interleaved = list(db.chapters)
	# Insert combined chapter list into g_chapter_list
	db.chapters_interleaved[db.books[5].first_chapter_offset:db.books[5].first_chapter_offset] = combined_chapter_list

	for chapter in db.chapters_interleaved:
		debug_print(repr(chapter))

	print("")

	db.episodes = parse_episodes()
	print("%i episodes" % len(db.episodes))

	print("")

	db.connections = parse_connections(db)
	print("%i episode-chapter connections" % len(db.connections))

	return db
