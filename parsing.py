#!/usr/bin/env python3

"""
Game of Thrones chapters vs episodes chart generator
Copyright (c) 2013-2018, Joel Geddert

This script generates an HTML file of the table.

Software License:
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.

A note from the author:
	The original chart generated by this code, as well as all remaining applicable
	source & asset files (except where noted), are licensed under a Creative Commons
	BY-SA 4.0 license <http://creativecommons.org/licenses/by-sa/4.0/>. If you are
	going to use any of this code to create a derivative work, please respect this
	CC license.
"""


from utils import *
import os.path
import csv


_chapterFilename = os.path.join('input', 'chapters.csv')
_combinedFilename = os.path.join('input', 'combined.txt')
_episodeFilename = os.path.join('input', 'episodes.csv')
_connectionsFilename = os.path.join('input', 'connections.csv')

_tab="\t"


def findChapter(chapName, bookNum):
	global g_chapterList
	global g_bookNChap

	chapter = [item for item in g_chapterList if (item['bookNum'] == bookNum) and (item['name'] == chapName)]

	if len(chapter) == 0:
		return {}

	if len(chapter) > 1:
		print("WARNING: multiple chapters found matching book #", bookNum, "named", chapName)

	return chapter[0]


# If wanting to return total chapter number instead
# The 1 is because chapters are zero-indexed in csv file (though probably want to change this later)
# return int(chapter[0]['number']) + 1 + sum(g_bookNChap[0:bookNum-1])


def findChapterByNumber(bookNum, chapNum):
	global g_chapterList
	global g_bookNChap

	chapter = [item for item in g_chapterList if (item['bookNum'] == bookNum) and (item['chapNum'] == chapNum)]

	if len(chapter) == 0:
		return {}

	if len(chapter) > 1:
		print("WARNING: multiple chapters found matching book #", bookNum, " chap#", chapNum, sep="")

	return chapter[0]


def parseChapters():
	print("Processing", _chapterFilename)
	chapterList = []
	bookList = []
	bookNChap = []
	totChapNum = 0
	with open(_chapterFilename) as csvFile:
		chapterfile = csv.reader(csvFile)
		bookname = ""
		bookNum = 0
		for row in chapterfile:
			prevbookname = bookname
			bookname = row[0]
			if bookname != "":
				chapNum = int(row[1])
				chapName = row[2]
				povchar = row[3]
				if povchar == '':
					# if no POV char given in CSV file, use first word of chapter name
					povchar = row[2].split()[0]
					if povchar[0:3].lower() in ["pro", "epi"]:
						# If it's a prologue/epilogue then always make it "other"
						povchar = "Other"
					elif povchar[0:3].lower() == "the":
						# IF it's a "the" chapter, there should be a pov char set!
						print("WARNING: no POV char given for chapter " + chapName)
						povchar = "Other"
				location = row[4]
				storyline = [row[5].lower()]
				if (row[6] != ""):
					storyline.append(row[6].lower())
				occurred = row[7]
				if bookname not in bookList:
					bookList.append(bookname)
					bookNum += 1
					bookNChap.append(1)
				else:
					bookNChap[bookNum - 1] += 1

				totChapNum += 1

				chapter = {'book': bookname,
						   'bookNum': bookNum,
						   'number': chapNum,
						   'totChapNum': totChapNum,
						   'name': chapName,
						   'pov': povchar,
						   'story': storyline,
						   'location': location,
						   'occurred': occurred}

				chapterList.append(chapter)
	debug_print(repr(chapterList[0:10]))

	return chapterList, bookList, bookNChap


def parseCombinedOrder():
	print("Processing", _combinedFilename)
	combinedChapterList = []
	with open(_combinedFilename, 'rU') as txtFile:
		line = txtFile.readline()
		while line:

			words = line.split()
			words = [word.lower() for word in words]

			bookNum = 0

			if 'affc' in words:
				bookNum = 4
				n = words.index('affc')
			elif 'adwd' in words:
				bookNum = 5
				n = words.index('adwd')
			else:
				print("ERROR: neither AFFC nor ADWD not found in line:")
				print(line)
				line = txtFile.readline()
				continue

			# combined.txt 1-indexes chapters
			chapNum = int(words[n + 1]) - 1

			chapter = g_chapterList[chapNum + g_bookChapOffset[bookNum - 1]]
			combinedChapterList.append(chapter)

			debug_print(chapter)
			debug_print(line)

			line = txtFile.readline()
	return combinedChapterList


def parseEpisodes():
	print("Processing", _episodeFilename)
	episodeList = []
	with open(_episodeFilename) as csvFile:
		episodeFile = csv.reader(csvFile)
		for row in episodeFile:
			season = row[0]
			if season != "":
				epname = row[3]
				epname = epname[1:-1]
				debug_print(epname)
				episode = {'season': season, 'name': epname}
				episodeList.append(episode)
	return episodeList


def parseConnections():
	print("Processing", _connectionsFilename)
	connList = []
	with open(_connectionsFilename) as csvFile:
		connectionfile = csv.reader(csvFile)
		for row in connectionfile:
			if row[0].isdigit():
				epNum = int(row[1]) + 10 * (int(row[0]) - 1)
				bookNum = int(row[2])
				chapName = row[3]
				strength = row[4]
				major = row[5]
				notes = row[6]

				if (chapName == '') or (chapName == '?'):
					continue

				if strength not in ['0', '1']:
					print("WARNING: chapter strength not 0 or 1")
					print(_tab, "book ", bookNum, " chapName ", chapName, sep="")
					print(_tab, "strength: ", strength, sep="")
					continue
				strength = int(strength)

				# Make sure chapter name is in the list of chapters!
				chapter = findChapter(chapName, bookNum)

				if (chapter == {}):
					print("WARNING: Chapter not found:")
					print(_tab, "book ", bookNum, " chapName ", chapName, sep="")
					print(_tab, "notes: ", notes, sep="")

				# This line causes it to crash when the chapter is incorrectly named (which is okay!)
				chapNum = int(chapter['number']) + 1 + sum(g_bookNChap[0:bookNum - 1])

				debug_print("chapName:", chapName, "chapNum:", chapNum)

				connection = {'epNum': epNum,
							  'bookNum': bookNum,
							  'chapName': chapName,
							  'totChapNum': chapNum,
							  'strength': strength,
							  'major': major,
							  'notes': notes}

				connList.append(connection)

	debug_print(repr(connList[0:10]))

	return connList


def do_parsing():
	global g_chapterList, g_bookList, g_interleavedChapterList
	global g_bookNChap, g_bookChapOffset
	global g_episodeList, g_connList

	g_chapterList, g_bookList, g_bookNChap = parseChapters()
	g_bookChapOffset = cumsum(g_bookNChap)

	#prepend 0 to start
	g_bookChapOffset[:0] = [0]

	print("")
	print(len(g_chapterList), "chapters in", len(g_bookList), "books:")
	for n in range(len(g_bookList)):
		print(n+1, g_bookList[n], '-', g_bookNChap[n], 'chapters, first chapter is', g_bookChapOffset[n]+1, 'overall')
	print("")

	combinedChapterList = parseCombinedOrder()

	print(len(combinedChapterList), "chapters in books 4+5")

	# Have to use list(), otherwise it just copies reference and that's bad
	g_interleavedChapterList = list(g_chapterList)
	# Insert combined chapter list into g_chapterList
	g_interleavedChapterList[g_bookChapOffset[5]:g_bookChapOffset[5]] = combinedChapterList

	for chapter in g_interleavedChapterList:
		debug_print(repr(chapter))

	print("")

	g_episodeList = parseEpisodes()
	numEpisodes = len(g_episodeList)
	print(repr(numEpisodes), "episodes")

	print("")

	g_connList = parseConnections()
	print(len(g_connList), "episode-chapter connections")

	return dict(
		g_chapterList=g_chapterList,
		g_bookList=g_bookList,
		g_interleavedChapterList=g_interleavedChapterList,
		g_bookNChap=g_bookNChap,
		g_bookChapOffset=g_bookChapOffset,
		g_episodeList=g_episodeList,
		g_connList=g_connList,
	)
