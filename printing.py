#!/usr/bin/env python3

"""
Game of Thrones chapters vs episodes chart generator
Copyright (c) 2013-2018, Joel Geddert

This script generates an HTML file of the table.

Software License:
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.

A note from the author:
	The original chart generated by this code, as well as all remaining applicable
	source & asset files (except where noted), are licensed under a Creative Commons
	BY-SA 4.0 license <http://creativecommons.org/licenses/by-sa/4.0/>. If you are
	going to use any of this code to create a derivative work, please respect this
	CC license.
"""


from utils import *
import os.path
import re


_htmlTemplateFilenameInter = os.path.join('input', 'template.html')
_htmlTemplateFilenamePrint = os.path.join('input', 'template-print.html')
_outputFilenameInter = os.path.join('output', 'bookshow.html')
_outputFilenamePrint = os.path.join('output-print', 'bookshow_print.html')


# Darken every n cells
_nStripe = 5

_tableLine = '<!--table-->'

# HTML indentation character - ASCII tab "\t", several spaces, or nothing.
_tab="\t"

# Windows EOL (\r\n)
_eol="\r\n"

_topLeftBox = '<img src=\"imgs/cornerbox.png\">'
#_topLeftBox = '&nbsp;'

_useImgHeaders = True

_hideShowSpoilersFromChapNames = False # Doesn't fully work!
_getSeasonOfChap = False # Doesn't fully work!

_currSeason = 5
_latestEpisode = 50

# abbreviated book names
_bookAbbrevs = ['AGoT','ACoK','ASoS','AFfC','ADwD','TWoW','ADoS']

# If chapter name is longer than this many characters, it will be abbreviated
# (Based on number of characters the stringLen function below will return, which is approximate)
_maxChapNameLength = 15


# Globals
g_db = None


# macro to output a line
def opl(line):
	# global vars g_opInterVer and g_opPrintVer are switches to turning printing to interactive version and print version on or off
	global g_opPrintVer, g_opInterVer
	global g_outFileInter, g_outFilePrint, _eol

	if g_opInterVer:
		g_outFileInter.write(line + _eol)
	if g_opPrintVer:
		g_outFilePrint.write(line + _eol)


# output, without eol
def op(line):
	global g_opPrintVer, g_opInterVer
	global g_outFileInter, g_outFilePrint, _eol
	if g_opInterVer:
		g_outFileInter.write(line)
	if g_opPrintVer:
		g_outFilePrint.write(line)


def is_chap_name_empty(chap_name):
	x = ''.join(ch for ch in chap_name if ch.isalnum())
	return (x == '')


# FIXME: this assumes always 10 episodes per season!
def get_season_num_for_ep_num(ep_num):
	return ((ep_num - 1) // 10) + 1


def get_all_chapters_with_pov(pov):
	assert g_db is not None
	chapters = [chapter for chapter in g_db.chapters if chapter['pov'] == pov]
	chapters = sorted(chapters, key=lambda k: k['totChapNum'])
	return chapters


# Unused, and doesn't work 100% (can enable with _getSeasonOfChap = True)
# This whole function is probably a bad idea, as this is somewhat subjective and should
# probably just be manually set like the connections themselves
# In any case, hiding spoilers by season isn't implemented anyway, so this won't do anything useful
def get_season_num_for_chapter(chapter, strong_conns_only=False):
	# Criteria:
	# 1. If chapter name is empty (e.g. unreleased chapters that show '?'), return 0
	# 2. If there is a strong connection, use 1st season the connection occurs in
	# 3. If "occurred" flag isn't set, return 0
	# 4. If there's a weak connection, return one of those (currently first, but that may need to change)
	# 5. Find next POV chapter of that character with a strong connection and use that one

	assert g_db is not None

	if is_chap_name_empty(chapter['name']):
		return 0

	# Make list of all connections that match this chapter
	conns = [item for item in g_db.connections if item['totChapNum'] == chapter['totChapNum']]
	conns = sorted(conns, key=lambda k: k['epNum'])

	if strong_conns_only:
		strongconns = [item for item in conns if item['strength'] > 0]

		if strongconns != []:
			return get_season_num_for_ep_num(strongconns[0]['epNum'])

	if chapter['occurred'] == '0':
		return 0

	if not strong_conns_only:
		if conns != []:
			return get_season_num_for_ep_num(conns[0]['epNum'])

	# Find next POV chapter of this character and use that chapter's number (recursively)
	chaps = get_all_chapters_with_pov(chapter['pov'])
	idx = chaps.index(chapter)
	if (idx + 1) < len(chaps):
		nextPovChap = chaps[idx + 1]
		# TODO: change this to strong_conns_only=True (but make that actually work)
		return get_season_num_for_chapter(nextPovChap, strong_conns_only=False)

	# No connection was found
	print('WARNING: Book', chapter['bookNum'], 'Chapter', chapter['name'],
		  'has no strong connections but has occurred flag set')
	return 0


def print_html_header():
	global g_opInterVer, g_opPrintVer
	print("Writing HTML header")

	g_opInterVer = True
	g_opPrintVer = False
	line = ''
	while _tableLine not in line:
		line = g_inFileInter.readline()

		if not line.endswith('\n'):
			print("ERROR: line", _tableLine, "not found!")
			exit()

		op(line)

	g_opInterVer = False
	g_opPrintVer = True
	line = ''
	while _tableLine not in line:
		line = g_inFilePrint.readline()

		if not line.endswith('\n'):
			print("ERROR: line", _tableLine, "not found!")
			exit()

		op(line)

	g_opInterVer = True
	g_opPrintVer = True


def print_html_footer():
	global g_opInterVer, g_opPrintVer
	print("Writing HTML footer")

	g_opInterVer = True
	g_opPrintVer = False
	while True:
		line = g_inFileInter.readline()
		if not line.endswith('\n'):
			break;
		op(line)

	g_opInterVer = False
	g_opPrintVer = True
	while True:
		line = g_inFilePrint.readline()
		if not line.endswith('\n'):
			break;
		op(line)

	g_opInterVer = True
	g_opPrintVer = True


def print_book_title_cells():
	assert g_db is not None
	for n in range(len(g_db.books)):

		# Column that summarizes book (for when column set is collapsed)
		classes = "booktitle b" + str(n + 1) + "title b" + str(n + 1) + "c"
		op(_tab + "<th rowspan=\"2\" class=\"" + classes + "\" onclick=\"expandbook(" + str(n + 1) + ")\">")

		if _useImgHeaders:
			opl("<img src=\"imgs/b" + str(n + 1) + "coll.png\" alt=\"" + g_db.books[n] + "\">")
		else:
			op("<div class=\"booktitleabbrevrotate\"><div class=\"booktitleabbrevinside\">")
			op(_bookAbbrevs[n])
			op("</div></div>")

		opl("</th>")

		classes = "booktitle b" + str(n + 1) + "title b" + str(n + 1)
		op(_tab + "<th colspan=\"" + str(g_db.chapters_per_book[n]) + "\" class=\"" + classes + "\" onclick=\"collapsebook(" + str(
			n + 1) + ")\">")

		if _useImgHeaders:
			opl("<img src=\"imgs/b" + str(n + 1) + "title.png\" alt=\"" + g_db.books[n] + "\">")
		else:
			op(g_db.books[n])
		opl("</th>")

		if (n == 4):
			# Print combined order

			# Use 45 as bookNum for css (as much as I like the series, I hope it never hits 45 books...)
			classes = "booktitle b45title b45c"
			op(_tab + "<th rowspan=\"2\" class=\"" + classes + "\" onclick=\"expandbook(45)\">")

			if _useImgHeaders:
				opl("<img src=\"imgs/b45coll.png\" alt=\"" + g_db.books[3] + " &amp; " + g_db.books[4] + " (Chronological)\">")
			else:
				op("<div class=\"booktitleabbrevrotate\"><div class=\"booktitleabbrevinside\">")
				op("4+5")
				op("</div></div>")

			opl("</th>")

			classes = "booktitle b45title b45"
			op(_tab + "<th colspan=\"" + str(g_db.chapters_per_book[3] + g_db.chapters_per_book[4]) + "\" class=\"" + classes + "\" onclick=\"collapsebook(45)\">")

			if _useImgHeaders:
				op("<img src=\"imgs/b45title.png\" alt=\"" + g_db.books[3] + " &amp; " + g_db.books[4] + " (Chronological)\">")
			else:
				op(g_db.books[3] + " &amp; " + g_db.books[4] + " (Chronological)")

			opl("</th>")


def print_chapter_title_cells(chapters):
	assert g_db is not None
	
	n = 0
	combinedsection = 0
	prevchapbooknum = -1
	prevchapnum = -1

	for chap in g_db.chapters_interleaved:

		bookNum = int(chap.book_num)
		chapNum = int(chap.number)

		# Determine if chapter is new book

		# if gone down in book number or chapter number
		if (bookNum <= prevchapbooknum):
			if (chapNum <= prevchapnum):
				if not combinedsection:
					n = 0
				combinedsection = 1

				debug_print("bookNum=", bookNum, " chapNum=", chapNum, sep="")

		elif bookNum == 6:
			combinedsection = 0

		if (bookNum != prevchapbooknum and not combinedsection):
			debug_print("bookNum=", bookNum, " prevchapbooknum=", prevchapbooknum, " combinedsection=", combinedsection,
						sep="")
			n = 0

		chapName = chap.name

		# For "?" chapters after TWOW preview chaps
		chapNameIsntReal = is_chap_name_empty(chapName)

		# if name longer than ~15 characters, abbreviate
		if combinedsection:
			# If we're in combined section, prepend book number to chapter
			chapName = abbrevString(chapName, _maxChapNameLength, str(bookNum))
		else:
			chapName = abbrevString(chapName, _maxChapNameLength)

		if chapNameIsntReal:
			classes = "cn b" + str(chap.book_num) + " bb"

			if (chap.number == 0):
				classes += " lb"
			elif (n == g_db.chapters_per_book[int(chap.book_num) - 1] - 1):
				classes += " rb"

		elif combinedsection:
			classes = "cn b45 b" + str(bookNum) + "co bb"

			if (n == 0):
				classes += " lb"
			elif (chapNum == (g_db.chapters_per_book[4] - 1)):
				classes += " rb"

		else:
			classes = "cn b" + str(chap.book_num) + " bb"

			if (chap.number == 0):
				classes += " lb"
			elif (n == g_db.chapters_per_book[int(chap.book_num) - 1] - 1):
				classes += " rb"

		if n % _nStripe == 0:
			classes += " s"

		if chapNameIsntReal:
			opl(_tab + "<th class=\"" + classes + "\"><div class=\"cni nonrotate\">?</div></th>")

		else:
			classes2 = "cni"

			if _getSeasonOfChap:
				# Get episode number that corresponds to this chapter (used for hiding show spoilers)
				chapSeason = get_season_num_for_chapter(chap)

				debug_print('Chapter', chap['totChapNum'], 'chapSeason', chapSeason)

				if chapSeason == 0:
					classes2 += " ho"
				elif _hideShowSpoilersFromChapNames:
					classes2 += " seas" + str(chapSeason)

			elif chap.occurred == '0':
				classes2 += " ho"

			opl(_tab + "<th class=\"" + classes + "\" title=\"" + chap.name + "\"><div class=\"cnr\"><div class=\"" + classes2 + "\">" + chapName + "</div></div></th>")
		n += 1

		prevchapbooknum = bookNum
		prevchapnum = chapNum


def print_body_cells(seasEpNum, totEpNum):
	assert g_db is not None

	# First, make list of all connections that match this episode
	conns = [item for item in g_db.connections if item.ep_num == totEpNum]

	connums = [item.tot_chap_num for item in conns]

	debug_print("episode ", totEpNum, ", ", len(conns), " connections: ", repr(connums), sep="")
	debug_print(repr(conns), _eol)

	prevbooknum = -1
	prevchapnum = -1
	combined45section = 0
	totChapNum = 1

	debugprintthisline = (totEpNum == 1)

	for chapter in g_db.chapters_interleaved:

		isnewbook = 0

		bookNum = int(chapter.book_num)
		chapNum = int(chapter.number)

		totChapNum = chapter.tot_chap_num

		# Determine if chapter is new book

		# if gone down in both book number and chapter number, we're in 4+5 combined section
		if (bookNum <= prevbooknum):
			if (chapNum <= prevchapnum):
				if not combined45section:
					isnewbook = 1
				combined45section = 1
		elif bookNum == 6:
			combined45section = 0

		if ((bookNum != prevbooknum) and not combined45section):
			isnewbook = 1

		if debugprintthisline:
			if isnewbook:
				if not combined45section:
					debug_print('')
					debug_print('Book', bookNum, 'start')
				else:
					debug_print('')
					debug_print('Book 4+5 combined start')

		prevbooknum = bookNum
		prevchapnum = chapNum

		if isnewbook:
			n = 0

			# Add book summary cell

			if not combined45section:
				classes = "b" + str(bookNum) + "c lb rb"
			else:
				classes = "b45c lb rb"

			if seasEpNum == 1:
				classes += " tb"
			elif (seasEpNum == 10):
				classes += " bb"
			if (seasEpNum - 1) % _nStripe == 0:
				classes += " s"

			op(_tab + "<td class=\"" + classes + "\">")

			# Get all connections matching this episode
			if not combined45section:
				epbookconns = [item for item in conns if ((item.ep_num == totEpNum) and (item.book_num == bookNum))]
			else:
				epbookconns = [item for item in conns if ((item.ep_num == totEpNum) and (item.book_num in [4, 5]))]

			# Is there a connection? If so, make div inside cell
			if epbookconns != []:

				classes = "c"

				# Now figure out if there are strong connections or only weak

				strongepbookconns = [item for item in epbookconns if item.strength == 1]

				if strongepbookconns == []:
					classes += " wc"
				else:
					classes += " sc"

				op("<div class=\"" + classes + "\"></div>")

			opl("</td>")

		# Print cell

		if debugprintthisline:
			debug_print("Book", bookNum, "Chapter", chapNum)

		if not combined45section:
			classes = "b" + str(bookNum)
		else:
			classes = "b45 b" + str(bookNum) + "co"

		if (seasEpNum == 1):
			classes += " tb"
		if (seasEpNum == 10):
			classes += " bb"

		if not combined45section:
			if (chapNum == 0):
				classes += "  lb"
			if (chapNum == g_db.chapters_per_book[bookNum - 1] - 1):
				classes += " rb"
		else:
			if (bookNum == 4 and chapNum == 0):
				classes += " lb"
			if (bookNum == 5 and chapNum == (g_db.chapters_per_book[4] - 1)):
				classes += " rb"

		if (n % _nStripe == 0) or ((seasEpNum - 1) % _nStripe == 0):
			classes += " s"

		if debugprintthisline:
			if 'lb' in classes:
				debug_print('left border')
			if 'rb' in classes:
				debug_print('right border')

		op("<td class=\"" + classes + "\">")

		# Is there a connection? If so, make div inside cell
		if totChapNum in connums:
			conn = [item for item in conns if item.tot_chap_num == totChapNum][0]

			chap = g_db.chapters[totChapNum - 1]
			povchar = chap.pov.lower()
			location = chap.location.lower()

			classes = "c pov" + povchar

			if False:
				# None of these are implemented in html/js/css anyway, so there's no point to doing them

				classes += " loc" + location

				# TODO: multiple storylines
				storyline = chap['story'][0]
				if storyline != "":
					classes += " sto" + storyline

			if conn.strength == 0:
				classes += " wc"
			else:
				classes += " sc"

			title = re.sub('"', '&quot;', conn.notes)

			op("<div class=\"" + classes + "\" title=\"" + title + "\"></div>")

		op("</td>")
		n += 1


# isBody indicates if this is the one that goes inside the main table
# isEnd indicates if this is the one that goes at the very end (for print version)
def print_episode_rows(isBody, isEnd=False):
	assert g_db is not None

	prevseason = ''
	seasEpNum = 0
	totEpNum = 0

	hideOnFloat = ''
	if isBody:
		hideOnFloat = ' hideonfloat'
	for episode in g_db.episodes:

		totEpNum += 1

		if (seasEpNum % _nStripe == 0):
			stripe = ' s'
		else:
			stripe = ''

		seasonclass = "seas" + episode.season

		seasontitleclass = seasonclass + "title"

		if int(episode.season) == _currSeason:
			if totEpNum <= _latestEpisode:
				seasonclass += "aired"
			else:
				seasonclass += "unaired"

		if episode.season != prevseason:
			opl("<tr class=\"eprow epkeyrow " + seasonclass + "\">")
			prevseason = episode.season
			seasEpNum = 1
		else:
			opl("<tr class=\"eprow " + seasonclass + "\">")
			seasEpNum += 1

		classes = stripe
		if (seasEpNum == 1):
			classes += " tb"
		elif (seasEpNum == 10):
			classes += " bb"

		if isEnd:
			op(_tab + "<th class=\"eptitle lb" + classes + hideOnFloat + "\">")
			op("<div class=\"eptitleinside\">")
			opl(episode.name + "</div></th>")
			opl(_tab + "<th class=\"epnum" + classes + hideOnFloat + " rb\">" + str(seasEpNum) + "</th>")

		if seasEpNum == 1:
			opl(_tab + "<th rowspan=\"10\" class=\"seasontitle " + seasontitleclass + hideOnFloat + "\">")

			if _useImgHeaders:
				opl("<img src=\"imgs/s" + str(episode.season) + "title.png\" alt=\"Season " + str(
					episode.season) + "\">")
			else:
				opl(_tab + _tab + "<div class=\"seasonnamerotate\">")
				opl(_tab + _tab + _tab + "<div class=\"seasonnameinside\">Season " + toRomanNumeral(
					int(episode.season)) + "</div>")
				opl(_tab + _tab + "</div>")

			opl(_tab + "</th>")

		if not isEnd:
			opl(_tab + "<th class=\"epnum" + classes + hideOnFloat + "\">" + str(seasEpNum) + "</th>")
			op(_tab + "<th class=\"eptitle rb" + classes + hideOnFloat + "\">")
			op("<div class=\"eptitleinside\">")
			opl(episode.name + "</div></th>")

		if isBody:
			print_body_cells(seasEpNum, totEpNum)

		opl("</tr>")


def do_printing(db):
	global g_db
	global g_inFileInter, g_inFilePrint, g_outFileInter, g_outFilePrint, g_opInterVer, g_opPrintVer

	g_db = db

	g_opInterVer = True
	g_opPrintVer = True

	print("Creating output file:", _outputFilenameInter)

	g_inFileInter = open(_htmlTemplateFilenameInter, 'r')
	g_inFilePrint = open(_htmlTemplateFilenamePrint, 'r')
	g_outFileInter = open(_outputFilenameInter,'w')
	g_outFilePrint = open(_outputFilenamePrint,'w')

	print_html_header()

	opl("<div id=\"tablediv\" class=\"cpov spoiler_b0\">")

	##### Print floating table #####

	print("Writing floating table")

	g_opPrintVer = False

	opl("<table id=\"floatingtable\">")

	opl("<thead>")
	opl("<tr class=\"booktitlerow\">")
	opl(_tab + "<th colspan=\"3\" rowspan=\"2\" class=\"cornerbox rb\"><div class=\"cornerboxdiv\">" + _topLeftBox + "</div></th>")
	opl("</tr>")
	opl("<tr></tr>")
	opl("</thead>")

	print_episode_rows(isBody=False)


	g_opPrintVer = False
	opl("</table>")

	##### thead #####

	print("Writing table chapter headers")

	g_opPrintVer = True

	opl("<div id=\"maintablediv\">")

	opl("<table id=\"maintable\">")
	opl("<thead>")
	opl("<tr class=\"booktitlerow\">")

	# Non-floating top-left box
	opl(_tab + "<th colspan=\"3\" rowspan=\"2\" class=\"cornerbox hideonfloat\"><div class=\"cornerboxdiv\">" + _topLeftBox + "</div></th>")

	print_book_title_cells()

	opl("</tr>")
	opl("<tr>")

	print_chapter_title_cells(db.chapters)

	opl("</tr>")
	opl("</thead>")

	##### tbody #####

	opl("<tbody>")

	print("")
	print("***** Writing table body *****")
	print("")

	print_episode_rows(isBody=True)

	opl("</tbody>")
	opl("</table>")
	opl("</div> <!-- /maintablediv -->")

	##### Print floating table - print version only #####

	g_opPrintVer = True
	g_opInterVer = False

	opl("<table id=\"floatingtable\">")

	opl("<thead>")
	opl("<tr class=\"booktitlerow\">")
	opl(_tab + "<th colspan=\"3\" rowspan=\"2\" class=\"cornerbox lb\"><div class=\"cornerboxdiv\">&nbsp;</div></th>")
	opl("</tr>")
	opl("<tr></tr>")
	opl("</thead>")

	print_episode_rows(isBody=False, isEnd=True)

	opl("</table>")

	##### Done #####

	g_opPrintVer = True
	g_opInterVer = True
	opl("</div> <!-- /tablediv -->")

	print("")
	print("***** Table body complete *****")
	print("")

	print_html_footer()

	print("Closing HTML files")
	g_inFileInter.close()
	g_inFilePrint.close()
	g_outFileInter.close()
	g_outFilePrint.close()
