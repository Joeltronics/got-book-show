#!/usr/bin/env python3

"""
Game of Thrones chapters vs episodes chart generator
Copyright (c) 2013-2018, Joel Geddert

This script generates an HTML file of the table.

Software License:
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.

A note from the author:
	The original chart generated by this code, as well as all remaining applicable
	source & asset files (except where noted), are licensed under a Creative Commons
	BY-SA 4.0 license <http://creativecommons.org/licenses/by-sa/4.0/>. If you are
	going to use any of this code to create a derivative work, please respect this
	CC license.
"""


from utils import *
import os.path


# Darken every n cells
_nStripe = 5

_tableLine = '<!--table-->'

# HTML indentation character - ASCII tab "\t", several spaces, or nothing.
_tab="\t"

# Windows EOL (\r\n)
_eol="\r\n"

_topLeftBox = '<img src="imgs/cornerbox.png">'

_useImgHeaders = True

_currSeason = 5
_latestEpisode = 50

# If chapter name is longer than this many characters, it will be abbreviated
# Based on number of utils.display_string_len_approx() returns
_maxChapNameLength = 15


# Globals

g_db = None


class FileWriter:
	def __init__(self, *files):
		self.files = files

	def op(self, text, indent=0):
		for file in self.files:
			indentation = ''.join([_tab] * indent)
			file.write(indentation + text)


	def opl(self, text, indent=0):
		self.op(text + _eol, indent=indent)


def is_chap_name_empty(chap_name):
	x = ''.join(ch for ch in chap_name if ch.isalnum())
	return x == ''


def get_all_chapters_with_pov(pov):
	assert g_db is not None
	chapters = [chapter for chapter in g_db.chapters if chapter['pov'] == pov]
	chapters = sorted(chapters, key=lambda k: k['totChapNum'])
	return chapters


def print_html_header(writer: FileWriter, in_file):
	line = ''
	while _tableLine not in line:
		line = in_file.readline()

		if not line.endswith('\n'):
			raise ValueError('Error: line %s not found' % _tableLine)

		writer.op(line)


def print_html_footer(writer: FileWriter, in_file):
	while True:
		line = in_file.readline()
		if not line.endswith('\n'):
			break
		writer.op(line)


def print_book_title_cells(writer: FileWriter):
	assert g_db is not None

	op = writer.op
	opl = writer.opl

	for n, book in enumerate(g_db.books):

		# Column that summarizes book (for when column set is collapsed)
		classes = 'booktitle b%ititle b%ic' % (book.number, book.number)
		op('<th rowspan="2" class="%s" onclick="expandbook(%i)">' % (classes, book.number), indent=1)

		book_name = htmlize_string(book.name)

		if _useImgHeaders:
			opl('<img src="imgs/b%icoll.png" alt="%s">' % (book.number, book_name))
		else:
			op('<div class="booktitleabbrevrotate"><div class="booktitleabbrevinside">')
			op(book.abbreviation)
			op('</div></div>')

		opl('</th>')

		classes = 'booktitle b%ititle b%i' % (book.number, book.number)
		op('<th colspan="%i" class="%s" onclick="collapsebook(%i)">' % (len(book.chapters), classes, book.number), indent=1)

		if _useImgHeaders:
			opl('<img src="imgs/b%ititle.png" alt="%s">' % (book.number, book_name))
		else:
			op(book_name)
		opl('</th>')


def print_chapter_title_cells(writer: FileWriter):
	assert g_db is not None

	op = writer.op
	opl = writer.opl

	for book in g_db.books:
		for stripe_counter, chap in enumerate(book.chapters):

			chap_num = int(chap.number_in_book)

			# For "?" chapters after TWOW preview chaps
			chap_name_isnt_real = is_chap_name_empty(chap.name)

			# if name longer than ~15 characters, abbreviate
			# If we're in combined section, prepend book number to chapter
			# Want real book number, not fake combined book number, so use chap.book.number rather than book.number
			chap_name_to_display = abbrev_string(
				chap.name,
				_maxChapNameLength,
				prefix=str(chap.book.number) if book.is_combined else None)

			if chap_name_isnt_real:
				classes = ["cn", "b%i" % chap.book.number, "bb"]

				if chap.number_in_book == 0:
					classes.append("lb")
				elif stripe_counter == len(chap.book.chapters) - 1:
					classes.append("rb")

			elif book.is_combined:
				# Again, chap.book.number is different from book.number when combined
				classes = ["cn", "b%i" % book.number, "b%ico" % chap.book.number, "bb"]

				if stripe_counter == 0:
					classes.append("lb")
				elif chap_num == (len(g_db.books[4].chapters) - 1):
					classes.append("rb")

			else:
				classes = ["cn", "b%i" % chap.book.number, "bb"]

				if chap.number_in_book == 0:
					classes.append("lb")
				elif stripe_counter == len(chap.book.chapters) - 1:
					classes.append("rb")

			if stripe_counter % _nStripe == 0:
				classes.append("s")

			if chap_name_isnt_real:
				opl('<th class="%s"><div class="cni nonrotate">?</div></th>' % (' '.join(classes)), indent=1)

			else:
				classes2 = "cni"

				if not chap.occurred:
					classes2 += " ho"

				opl('<th class="%s" title="%s"><div class="cnr"><div class="%s">%s</div></div></th>' % (
					' '.join(classes), chap.name, classes2, chap_name_to_display), indent=1)


def print_body_cells(writer: FileWriter, episode, seas_ep_num, debug_print_this_line=False):
	assert g_db is not None

	op = writer.op
	opl = writer.opl

	# First, make list of all connections that match this episode
	connections = [item for item in g_db.connections if item.episode == episode]

	connection_chapter_nums = [item.chapter.number for item in connections]

	debug_print("episode %i, %i connections: %s" % (episode.number, len(connections), repr(connection_chapter_nums)))
	debug_print(repr(connections) + _eol)

	for book in g_db.books:

		if debug_print_this_line:
			if not book.is_combined:
				debug_print('')
				debug_print('Book %i start' % book.number)
			else:
				debug_print('')
				debug_print('Book 4+5 combined start')

		# Add book summary cell

		classes = ["b%ic" % book.number, "lb", "rb"]

		if seas_ep_num == 1:
			classes.append("tb")
		elif seas_ep_num == len(episode.season.episodes):
			classes.append("bb")

		if (seas_ep_num - 1) % _nStripe == 0:
			classes.append("s")

		op('<td class="%s">' % ' '.join(classes), indent=1)

		# Get all connections matching this episode
		if book.is_combined:
			ep_book_connections = [
				item for item in connections
				if (item.episode.number == episode.number) and (item.chapter.book in book.combined_books)
			]
		else:
			ep_book_connections = [
				item for item in connections
				if (item.episode.number == episode.number) and (item.chapter.book.number == book.number)
			]

		# Is there a connection? If so, make div inside cell
		if ep_book_connections:
			classes = ["c"]

			# Now figure out if there are strong connections or only weak
			if any([item.strength == 1 for item in ep_book_connections]):
				classes.append("sc")
			else:
				classes.append("wc")

			op('<div class="%s"></div>' % ' '.join(classes))

		opl("</td>")

		for stripe_counter, chapter in enumerate(book.chapters):

			# For combined book, may be different from book.number
			book_num = chapter.book.number
			chap_num_in_book = chapter.number_in_book

			# Print cell

			if debug_print_this_line:
				debug_print("Book %i, Chapter %i" % (book_num, chap_num_in_book))

			if not book.is_combined:
				classes = ["b%i" % book_num]
			else:
				classes = ["b%i" % book.number, "b%ico" % book_num]

			if seas_ep_num == 1:
				classes.append("tb")
			if seas_ep_num == len(episode.season.episodes):
				classes.append("bb")

			if not book.is_combined:
				if chap_num_in_book == 0:
					classes.append("lb")

				if chap_num_in_book == len(chapter.book.chapters) - 1:
					classes.append("rb")
			else:
				# Assume first chapter of first book is first chronological, and last chapter of last book is last
				# This is true for AFfC and ADwD, anyway...
				first_combined_book = book.combined_books[0]
				last_combined_book = book.combined_books[-1]
				if book_num == first_combined_book.number and chap_num_in_book == 0:
					classes.append("lb")
				if book_num == last_combined_book.number and chap_num_in_book == (len(last_combined_book.chapters) - 1):
					classes.append("rb")

			if (stripe_counter % _nStripe == 0) or ((seas_ep_num - 1) % _nStripe == 0):
				classes.append("s")

			if debug_print_this_line:
				if 'lb' in classes:
					debug_print('left border')
				if 'rb' in classes:
					debug_print('right border')

			op('<td class="%s">' % ' '.join(classes))

			# Is there a connection? If so, make div inside cell
			if chapter.number in connection_chapter_nums:
				conn = [item for item in connections if item.chapter.number == chapter.number][0]
				classes = ["c", "pov%s" % chapter.pov.lower()]

				if conn.strength == 0:
					classes.append("wc")
				else:
					classes.append("sc")

				title = htmlize_string(conn.notes)

				op('<div class="%s" title="%s"></div>' % (' '.join(classes), title))

			op('</td>')


def print_episode_rows(writer: FileWriter, is_body: bool, is_end=False):
	"""
	:param writer:
	:param is_body: indicates if this is the one that goes inside the main table
	:param is_end: indicates if this is the one that goes at the very end (for print version)
	"""
	assert g_db is not None

	op = writer.op
	opl = writer.opl

	hide_on_float = ' hideonfloat' if is_body else ''

	for season in g_db.seasons:
		for seas_ep_idx, episode in enumerate(season.episodes):

			seas_ep_num = seas_ep_idx + 1

			if seas_ep_idx % _nStripe == 0:
				stripe = ' s'
			else:
				stripe = ''

			season_class = "seas%i" % season.number

			season_title_class = season_class + "title"

			if season.number == _currSeason:
				if episode.number <= _latestEpisode:
					season_class += "aired"
				else:
					season_class += "unaired"

			if seas_ep_idx == 0:
				opl('<tr class="eprow epkeyrow %s">' % season_class)
			else:
				opl('<tr class="eprow %s">' % season_class)

			classes = stripe
			if seas_ep_idx == 0:
				classes += " tb"
			elif seas_ep_idx == len(season.episodes) - 1:
				classes += " bb"

			if is_end:
				op('<th class="eptitle lb%s%s">' % (classes, hide_on_float), indent=1)
				op('<div class="eptitleinside">')
				opl(episode.name + "</div></th>")
				opl('<th class="epnum%s%s rb">%i</th>' % (classes, hide_on_float, seas_ep_num), indent=1)

			if seas_ep_idx == 0:
				opl('<th rowspan="10" class="seasontitle %s%s">' % (season_title_class, hide_on_float), indent=1)

				if _useImgHeaders:
					opl('<img src="imgs/s%ititle.png" alt="Season %i">' % (episode.season.number, episode.season.number))
				else:
					opl('<div class="seasonnamerotate">', indent=2)
					opl('<div class="seasonnameinside">Season %s</div>' % to_roman_numeral(
						int(episode.season.number)), indent=3)
					opl("</div>", indent=2)

				opl("</th>", indent=1)

			if not is_end:
				opl('<th class="epnum%s%s">%i</th>' % (classes, hide_on_float, seas_ep_num), indent=1)
				op('<th class="eptitle rb%s%s">' % (classes, hide_on_float), indent=1)
				op('<div class="eptitleinside">')
				opl(episode.name + "</div></th>")

			if is_body:
				print_body_cells(writer, episode, seas_ep_num, debug_print_this_line=(episode.number == 1))

			opl("</tr>")


def do_printing(db, input_dir='input', output_dir='output', output_print_dir='output-print'):
	global g_db

	g_db = db

	html_template_filename_inter = os.path.join(input_dir, 'template.html')
	html_template_filename_print = os.path.join(input_dir, 'template-print.html')
	output_filename_inter = os.path.join(output_dir, 'bookshow.html')
	output_filename_print = os.path.join(output_print_dir, 'bookshow_print.html')

	print('Opening files')
	with \
			open(html_template_filename_inter, 'r') as in_file_interactive, \
			open(html_template_filename_print, 'r') as in_file_print, \
			open(output_filename_inter, 'w') as out_file_interactive, \
			open(output_filename_print, 'w') as out_file_print:

		both_writer = FileWriter(out_file_print, out_file_interactive)
		inter_writer = FileWriter(out_file_interactive)
		print_writer = FileWriter(out_file_print)

		w = both_writer

		print('Writing HTML Header')
		print_html_header(inter_writer, in_file_interactive)
		print_html_header(print_writer, in_file_print)

		w.opl('<div id="tablediv" class="cpov spoiler_b0">')

		##### Print floating table #####

		print("Writing floating table")

		w = inter_writer

		w.opl('<table id="floatingtable">')

		w.opl('<thead>')
		w.opl('<tr class="booktitlerow">')
		w.opl('<th colspan="3" rowspan="2" class="cornerbox rb"><div class="cornerboxdiv">%s</div></th>' % _topLeftBox, indent=1)
		w.opl('</tr>')
		w.opl('<tr></tr>')
		w.opl('</thead>')

		print_episode_rows(w, is_body=False)

		w.opl("</table>")

		##### thead #####

		print("Writing table chapter headers")

		w = both_writer

		w.opl('<div id="maintablediv">')

		w.opl('<table id="maintable">')
		w.opl('<thead>')
		w.opl('<tr class="booktitlerow">')

		# Non-floating top-left box
		w.opl('<th colspan="3" rowspan="2" class="cornerbox hideonfloat"><div class="cornerboxdiv">%s</div></th>' % _topLeftBox, indent=1)

		print_book_title_cells(w)

		w.opl("</tr>")
		w.opl("<tr>")

		print_chapter_title_cells(w)

		w.opl("</tr>")
		w.opl("</thead>")

		##### tbody #####

		w.opl("<tbody>")

		print("")
		print("***** Writing table body *****")
		print("")

		print_episode_rows(w, is_body=True)

		w.opl("</tbody>")
		w.opl("</table>")
		w.opl("</div> <!-- /maintablediv -->")

		##### Print floating table - print version only #####

		w = print_writer

		w.opl('<table id="floatingtable">')

		w.opl('<thead>')
		w.opl('<tr class="booktitlerow">')
		w.opl('<th colspan="3" rowspan="2" class="cornerbox lb"><div class="cornerboxdiv">&nbsp;</div></th>', indent=1
			  )
		w.opl("</tr>")
		w.opl("<tr></tr>")
		w.opl("</thead>")

		print_episode_rows(w, is_body=False, is_end=True)

		w.opl("</table>")

		##### Done #####

		w = both_writer

		w.opl("</div> <!-- /tablediv -->")

		print("")
		print("***** Table body complete *****")
		print("")

		print('Writing HTML footer')
		print_html_footer(inter_writer, in_file_interactive)
		print_html_footer(print_writer, in_file_print)
