#!/usr/bin/env python3

"""
Game of Thrones chapters vs episodes chart generator
Copyright (c) 2013-2018, Joel Geddert

This script generates an HTML file of the table.

Software License:
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.

A note from the author:
	The original chart generated by this code, as well as all remaining applicable
	source & asset files (except where noted), are licensed under a Creative Commons
	BY-SA 4.0 license <http://creativecommons.org/licenses/by-sa/4.0/>. If you are
	going to use any of this code to create a derivative work, please respect this
	CC license.
"""


from typing import List, Optional
from utils import find_unique, concatenate_lists


class Book:

	is_combined = False

	def __init__(self, number: int, name: str, abbreviation: str, chapters: Optional[List]=None):
		"""
		:param number: 1-indexed
		:param name: book name
		:param abbreviation: abbreviation, e.g. "AGoT"
		:param chapters: list of chapters; can be given here or populated later
		"""
		self.number = number
		self.name = name
		self.abbreviation = abbreviation
		self.chapters = chapters if chapters is not None else []

	def __str__(self):
		return self.name

	def __repr__(self):
		return 'Book(%i: %s ("%s"), %i chapters)' % (
			self.number,
			self.name,
			self.abbreviation,
			len(self.chapters),
		)


class CombinedBook(Book):

	is_combined = True

	def __init__(self, number: int, name: str, abbreviation: str, combined_books: List[Book], chapters: Optional[List]=None):
		"""
		:param number: token to use for fake "book" in chart
		:param name: combined book name
		:param abbreviation: abbreviation, e.g. "AFfC + ADwD"
		:param combined_books: which books are combined
		:param chapters: list of chapters; can be given here or populated later
		"""
		super().__init__(number, name, abbreviation, chapters)
		self.combined_books = combined_books

	def __str__(self):
		return self.name

	def __repr__(self):
		return 'CombinedBook(%i: %s ("%s"), %i chapters)' % (
			self.number,
			self.name,
			self.abbreviation,
			len(self.chapters),
		)



class Chapter:
	def __init__(self, number: int, book: Book, number_in_book: int, name: str, pov_char: str, occurred: bool):
		"""

		:param number: chapter number (overall), 1-indexed
		:param book: reference to book
		:param number_in_book: number in book, 1-indexed
		:param name: chapter name
		:param pov_char: POV character
		:param occurred: if chapter has occurred in the show yet
		"""
		self.number = number
		self.book = book
		self.number_in_book = number_in_book
		self.name = name
		self.pov = pov_char
		self.occurred = occurred

	def __str__(self):
		return 'Chapter %i: "%s"' % (self.number, self.name)

	def __repr__(self):
		return 'Chapter(%i, %s %i: %s, POV %s, occurred: %s)' % (
			self.number, self.book.name, self.number_in_book, self.name, self.pov, str(self.occurred))


class Season:
	def __init__(self, number: int, episodes: Optional[List]=None):
		self.number = number
		self.episodes = episodes if episodes is not None else []


class Episode:
	def __init__(self, number: int, number_in_season: int, season: Season, name: str):
		"""
		:param number: episode number (overall), 1-indexed
		:param number_in_season: episode numbr in season, 1-indexed
		:param season: season number, 1-indexed
		:param name: episode name
		"""
		self.number = number
		self.number_in_season = number_in_season
		self.season = season
		self.name = name

	def __str__(self):
		return '%i: "%s", season %i' % (self.number, self.name, self.season.number)

	def __repr__(self):
		return 'Episode(%s)' % str(self)


class Connection:
	def __init__(self, episode: Episode, chapter: Chapter, strength: int, major: bool, notes: str):
		"""
		:param episode: Reference to episode
		:param chapter: Reference to chapter
		:param strength:
		:param major: Is this a major storyline event?
		:param notes: Notes to be shown in alt text
		"""
		self.episode = episode
		self.chapter = chapter
		self.strength = strength
		self.major = major
		self.notes = notes

	def __str__(self):
		return 'Episode %i, Chapter %i' % (self.episode.number, self.chapter.number)

	def __repr__(self):
		return 'Connection(Episode %i, Chapter %i, Strength %s, Major %s, Notes: %s)' % (
			self.episode.number, self.chapter.number, str(self.strength), str(self.major), self.notes)


class DB:
	def __init__(self):
		self.books = []
		self.chapters = []

		self.seasons = []
		self.episodes = []

		self.connections = []

	def find_chapter(self, chap_name, book_num):
		return find_unique(self.chapters, lambda chapter: (chapter.book.number == book_num) and (chapter.name == chap_name))


# There is some duplicate data in here for convenience sake. For example:
#   * Don't need chapter list since it's contained within books
#   * Don't need chapter.number_in_book, since that could be deduced from position in book.chapters
#   * Don't need chapter.number, since that could then further be deduced from book's position in db.books and number
#     of chapters in each book
#
# Of course, deducing these could be a pain
# If this was C and we were tight on memory, we could probably write a special function to do deduce this info for us...
# but what's a little duplicate state? ;)
#
# These sanity checks ensure this duplicate data is all correct


def sanity_check_books_chapters(books, chapters):

	real_books = [book for book in books if not book.is_combined]

	if not all([chapter.number == idx + 1 for idx, chapter in enumerate(chapters)]):
		raise ValueError('Chapter list is not sorted & complete')

	if not all([book.number == idx + 1 for idx, book in enumerate(real_books)]):
		raise ValueError('Book list is not sorted & complete')

	if chapters != concatenate_lists([book.chapters for book in real_books]):
		raise ValueError('Chapter list derived from books does not match general chapter list')

	for book in real_books:
		if not all([chapter.number_in_book == idx + 1 for idx, chapter in enumerate(book.chapters)]):
			raise ValueError('Chapter number in book does not match position in book list')
		if not all([chapter.book is book for chapter in book.chapters]):
			raise ValueError("Chapter's book reference does not match book it is in!")


def sanity_check_seasons_episodes(seasons, episodes):

	if not all([episode.number == idx + 1 for idx, episode in enumerate(episodes)]):
		raise ValueError('Episode list is not sorted & complete')

	if not all([season.number == idx + 1 for idx, season in enumerate(seasons)]):
		raise ValueError('Season list is not sorted & complete')

	if episodes != concatenate_lists([season.episodes for season in seasons]):
		raise ValueError('Episode list derived from seasons does not match general episode list')

	for season in seasons:
		if not all([episode.number_in_season == idx + 1 for idx, episode in enumerate(season.episodes)]):
			raise ValueError('Episode number in season does not match position in season list')
		if not all([episode.season is season for episode in season.episodes]):
			raise ValueError("Episodes's season reference does not match season it is in!")
